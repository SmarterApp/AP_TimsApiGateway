package org.opentestsystem.ap.apigateway.filter;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import org.apache.http.HttpHeaders;
import org.opentestsystem.ap.common.security.jwt.JwtService;
import org.opentestsystem.ap.common.security.jwt.support.BearerAuthorizationHeaders;
import org.opentestsystem.ap.common.security.model.User;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.provider.OAuth2Authentication;

/**
 * This filter enriches zuul-proxied requests with the spring security authentication principle
 * encoded into the Authentication header as a JWT
 */
public class JwtZuulFilter extends ZuulFilter {

    private final JwtService service;

    public JwtZuulFilter(final JwtService service) {
        this.service = service;
    }

    @Override
    public String filterType() {
        return "pre";
    }

    @Override
    public int filterOrder() {
        return 0;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    public Object run() {
        final String authorizationHeader = BearerAuthorizationHeaders.create(service.encode(this.getCurrentUser()));
        RequestContext.getCurrentContext().addZuulRequestHeader(HttpHeaders.AUTHORIZATION, authorizationHeader);
        return null;
    }

    private User getCurrentUser() {
        final Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null) {
            throw new IllegalStateException("user not authenticated");
        }

        Object principal = authentication.getPrincipal();

        if (authentication instanceof OAuth2Authentication) {
            OAuth2Authentication oAuth2Authentication = (OAuth2Authentication) authentication;
            final Authentication  userAuthentication = oAuth2Authentication.getUserAuthentication();
            if (userAuthentication == null) {
                throw new IllegalStateException("user not authenticated");
            }
            principal = userAuthentication.getPrincipal();
        }
        if (!(principal instanceof User)) {
            throw new ClassCastException("authentication principal must be of type " + User.class.getName());
        }
        return (User) principal;
    }

}
