package org.opentestsystem.ap.apigateway;

import com.okta.jwt.AccessTokenVerifier;
import com.okta.jwt.JwtVerificationException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.common.exceptions.InvalidTokenException;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.token.AccessTokenConverter;
import org.springframework.security.oauth2.provider.token.ResourceServerTokenServices;
import org.springframework.security.oauth2.provider.token.UserAuthenticationConverter;

import java.util.HashMap;
import java.util.Map;

/**
 * An implementation of {@link ResourceServerTokenServices} backed by Okta. It expects the access token to be
 * a JWT containing all the necessary OAuth information in its claims.
 */
@Slf4j
class OktaTokenServices implements ResourceServerTokenServices {
    private static final String AUD_CLAIM = "aud";

    private final AccessTokenConverter tokenConverter;
    private final AccessTokenVerifier verifier;


    OktaTokenServices(final AccessTokenConverter tokenConverter,
                             final AccessTokenVerifier verifier) {
        this.tokenConverter = tokenConverter;
        this.verifier = verifier;
    }

    @Override
    public OAuth2Authentication loadAuthentication(String accessToken) throws AuthenticationException, InvalidTokenException {

        Map map;
        try {
            map = verifier.decode(accessToken).getClaims();
            if (map.containsKey("error")) {
                throw new InvalidTokenException(accessToken);
            }
        } catch (JwtVerificationException e) {
            throw new InvalidTokenException(accessToken, e);
        }

        @SuppressWarnings("unchecked")
        OAuth2Authentication result = tokenConverter.extractAuthentication(sanitize(map));
        log.debug("Result {} grant type {} scope {}", result, result.getOAuth2Request().getGrantType(), result.getOAuth2Request().getScope());
        return result;
    }

    @Override
    public OAuth2AccessToken readAccessToken(String accessToken) {
        throw new UnsupportedOperationException("Not supported: read access token");
    }

    private Map<String, Object> sanitize(final Map<String, Object> claims) {
        // Remove the "aud" claim, because this interferes with the DefaultAccessTokenConverter
        Map<String, Object> sanitized = new HashMap<>(claims);
        sanitized.remove(AUD_CLAIM);

        // Tweak to user name parameter. Token info has both username and mail, but not user_name
        // user_name is needed downstream by the OAuth process, if there is a user_name value
        // then the authentication manager is called to authenticate the request and that is when
        // we look up the user's permission
        if (sanitized.containsKey("username")) {
            sanitized.put(UserAuthenticationConverter.USERNAME, sanitized.get("username"));
        } else if (sanitized.containsKey("mail")) {
            sanitized.put(UserAuthenticationConverter.USERNAME, sanitized.get("mail"));
        }
        return sanitized;
    }
}

