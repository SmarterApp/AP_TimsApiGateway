package org.opentestsystem.ap.apigateway;

import com.okta.jwt.AccessTokenVerifier;
import com.okta.jwt.JwtVerificationException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.common.exceptions.InvalidTokenException;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.token.AccessTokenConverter;
import org.springframework.security.oauth2.provider.token.ResourceServerTokenServices;

import java.util.HashMap;
import java.util.Map;

/**
 * An implementation of {@link ResourceServerTokenServices} backed by Okta. It expects the access token to be
 * a JWT containing all the necessary OAuth information in its claims.
 */
@Slf4j
class OktaTokenServices implements ResourceServerTokenServices {
    private static final String AUD_CLAIM = "aud";

    private final AccessTokenConverter tokenConverter;
    private final AccessTokenVerifier verifier;


    OktaTokenServices(final AccessTokenConverter tokenConverter,
                             final AccessTokenVerifier verifier) {
        this.tokenConverter = tokenConverter;
        this.verifier = verifier;
    }

    @Override
    public OAuth2Authentication loadAuthentication(String accessToken) throws AuthenticationException, InvalidTokenException {

        Map map;
        try {
            map = verifier.decode(accessToken).getClaims();
            if (map.containsKey("error")) {
                throw new InvalidTokenException(accessToken);
            }
        } catch (JwtVerificationException e) {
            throw new InvalidTokenException(accessToken, e);
        }

        @SuppressWarnings("unchecked")
        OAuth2Authentication result = tokenConverter.extractAuthentication(sanitize(map));
        log.debug("Result {} grant type {} scope {}", result, result.getOAuth2Request().getGrantType(), result.getOAuth2Request().getScope());
        return result;
    }

    @Override
    public OAuth2AccessToken readAccessToken(String accessToken) {
        throw new UnsupportedOperationException("Not supported: read access token");
    }

    private Map<String, Object> sanitize(final Map<String, Object> claims) {
        // Remove the "aud" claim, because this interferes with the DefaultAccessTokenConverter
        Map<String, Object> sanitized = new HashMap<>(claims);
        sanitized.remove(AUD_CLAIM);
        return sanitized;
    }
}

